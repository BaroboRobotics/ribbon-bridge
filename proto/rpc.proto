import "nanopb.proto";
package barobo.rpc;

enum Status {
    OK = 0;
    /* Cosmic rays */
    DECODING_FAILURE = 1;
    ENCODING_FAILURE = 2;
    INCONSISTENT_REQUEST = 3;
    INCONSISTENT_REPLY = 4;
    /* Operator error or version mismatches */
    /* Compile-time errors, if using same version of interface */
    ILLEGAL_OPERATION = 5;
    NO_SUCH_COMPONENT = 6;
    /* Runtime errors */
    BUFFER_OVERFLOW = 7;
}

message VersionTriplet {
    required uint32 major = 1;
    required uint32 minor = 2;
    required uint32 patch = 3;
}

message Request {
    enum Type {
        FIRE = 5;
        CONNECT = 6;
    }

    message Fire {
        required uint32 id = 1;
        required bytes payload = 2 [(nanopb).max_size = 128];
    }

    required Type type = 1;
    required uint32 id = 2;
    optional Fire fire = 7;
}

message Reply {
    enum Type {
        BROADCAST = 1;
        RESULT = 3;
        STATUS = 4;
        SERVICEINFO = 5;
    }

    message Broadcast {
        required uint32 id = 1;
        required bytes payload = 2 [(nanopb).max_size = 128];
    }

    message ServiceInfo {
        enum Type { WELCOME = 1; REFUSAL = 2; }
        required Type type = 1;
        required VersionTriplet rpcVersion = 2;
        required VersionTriplet interfaceVersion = 3;
    }

    message Result {
        required uint32 id = 2; // The component id. The Proxy should be able
                                // to figure this out by keeping a map of
                                // request IDs, but duplicating it here makes
                                // implementation much easier.
        required bytes payload = 3 [(nanopb).max_size = 128];
    }

    message Status {
        required barobo.rpc.Status value = 2;
    }

    required Type type = 1;
    optional uint32 inReplyTo = 2;
    optional Broadcast broadcast = 3;
    optional ServiceInfo serviceInfo = 4;
    optional Result result = 5;
    optional Status status = 6;
}
